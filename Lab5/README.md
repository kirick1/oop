# Лабораторна робота №5
## Тема роботи:
Реалізація складних поведінкових шаблонів проектування
## Мета роботи:
ознаойомлення з основними характеристиками шаблонів «Ланцюжок обов’язків», «Команда» та «Посередник», запам’ятовування поширених ситуацій, коли використання цих шаблонів є доцільним, набуття вмінь та навичок реалізації шаблонів під час створення програмного коду
## Теоретичні відомості:
#### __Ланцюжок обов'язків__
Поведінковий шаблон, призначений для організації в системі рівнів відповідальності
Будує об’єкти складених частин програми зв’язаними між собою ланцюжком для передачі запиту на обробку від більш низьких, деталізованих прошарків до більш глобальних
Дозволяє уникнути зв’язування відправника запиту та його отримувача

Поведінковий шаблон «Ланцюжок обов'язків» потрібно використовувати, коли:
* у розроблюваній системі є група об’єктів, які можуть оброблювати запит певного типу, причому справжній обробник запиту заздалегідь невідомий
* набір об’єктів, які обробляють запит, повинен визначатися динамічно
* потрібно відправити запит одному з декількох об’єктів, не вказуючи явно, якому саме
* всі повідомлення повинні бути оброблені хоча б одним об’єктом системи
* повідомлення в системі оброблюються за схемою “оброби сам або передай іншому”, тобто одні повідомлення обробляються на тому ж рівні, де вони були отримані, а інші – передаються об’єктам іншого рівня

Учасники шаблону:

* __Handler__ - визначає інтерфейс для обробки запитів, реалізує зв’язок зі спадкоємцем (необов’язково)
* __ConcreteHandler__ - оброблює запит, за який відповідає. Має доступ до свого спадкоємця. Якщо може самостійно обробити запит – робить це, якщо ні – передає його своєму спадкоємцю
* __Client__ – відправляє запит деякому об’єкту ConcreteHandler у ланцюжку

Коли клієнт ініціює запит, він починає просуватися ланцюжком, поки якийсь об’єкт ConcreteHandler не візьме на себе відповідальність за його обробку

#### __Команда__
Поведінковий шаблон, який інкапсулює різні алгоритми в єдину сутність (об’єкт), завдяки чому можна параметризувати клієнтів різними запитами, вести історію виконаних операцій та підтримувати скасування операцій
Відомий також під іменем Action (дія), Transaction (транзакція)
Забезпечує обробку команди у вигляді об’єкту, що дозволяє зберігати її, передавати у якості параметра методам, а також повертати її як результат методу

Поведінковий шаблон «Команда» потрібно використовувати, коли:
* треба параметризувати об’єкти виконуваною дією
* потрібно визначати, ставити в чергу та виконувати запити у різний час
* потрібно підтримати відміну операцій
* треба підтримати протоколювання змін (лог)
* структурувати систему на основі високорівневих операцій, побудованих з примітивних
* команди для різних отримувачів повинні бути оброблені у різний спосіб

Учасники шаблону:
* __Command__ - визначає інтерфейс для виконання операцій
* __ConcreteCommand__ - визначає зв’язок між об’єктом-отримувачем Receiver та дією; реалізує операцію Execute шляхом виклику відповідних операцій об’єкту Receiver
* __Client__ - створює об’єкти класу ConcreteCommand та встановлює їх отримувачів
* __Invoker__ - ініціатор. Звертається до команди для виконання запиту
* __Receiver__ - отримувач. Має інформацію про способи виконання операцій, необхідних для задоволення запиту. Отримувачем може бути будь-який клас

#### __Посередник__
Поведінковий шаблон, який надає єдиний центр взаємодії певної групи об’єктів, які повинні бути взаємнопов’язаними між собою. Визначає об'єкт, що інкапсулює спосіб взаємодії множини об'єктів

Поведінковий шаблон «Посередник» потрібно використовувати, коли:
* потрібно послабити зв’язність системи, позбавляючи об'єкти від необхідності явно посилатися один на одного і дозволяючи тим самим незалежно змінювати взаємодії між ними
* існують об'єкти, зв'язки між котрими досить складні та чітко задані. Отримані при цьому залежності не структуровані та важкі для розуміння
* не можна повторно використовувати об'єкт, оскільки він обмінюється інформацією з багатьма іншими об'єктами
* поведінка, розподілена між кількома класами, повинна піддаватися налагодженню без створювання множини підкласів

Учасники шаблону:
* __Mediator__ - визначає інтерфейс, що представляє інтерес для клієнтів. Зберігає екземпляр підкласу ConcreteState, яким визначається поточний стан
* __ConcreteMediator__ - реалізує кооперативне поведінку, координуючи дії об'єктів Colleague; володіє інформацією про колег і підраховує їх
* Класи __Colleague__ - кожен клас Colleague «знає» про свій об'єкті Mediator; всі колеги обмінюються інформацією лише з посередником, так як за його відсутності їм довелося б спілкуватися між собою безпосередньо

Колеги посилають запити посереднику та отримують повідомлення від нього. Посередник реалізує кооперативну поведінку шляхом переадресації кожного запиту відповідному колезі (або декільком колегам)

##### Індивідуальне завдання (Варіант 7)
1. Деякий галузевий концерн об’єднує декілька фабрик з виробництва устаткування для підприємств важкої промисловості. Замовлення на виготовлення продукції надходять з вказівкою, яка саме фабрика бажано повинна його виконати. У разі, якщо вказаній фабриці не вистачає ресурсів для виконання замовлення, вона передає замовлення іншій фабриці концерну. У випадку, якщо знайдено фабрику, яка може виконати замовлення, у клієнта перепитують, чи погоджується він спрямувати замовлення іншій фабриці. У випадку, якщо жодна фабрика не має ресурсів для виконання замовлення, про це сповіщається клієнт. За допомогою шаблону проектування змоделювати обробку замовлення концерном
2. User Component містить текстове поле для введення тексту та три кнопки для його збереження до файлу. У відповідність кожній кнопці поставлений окремий спосіб збереження тексту. Перший спосіб – звичайний: зберігаємо текст без внесення жодних змін. Другий спосіб – видаляємо всі зайві пробіли з тексту перед збереженням. Третій спосіб – застосовуємо кодування тексту (або архівацію). За допомогою шаблону проектування реалізувати описаний User Component, якщо відомо, що метод «Зберегти у файл» у нього один (немає жодних override варіантів методу)