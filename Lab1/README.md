# Лабораторна робота №1
## Тема роботи:
Реалізація структурних шаблонів проектування
## Мета роботи:
Ознаойомлення з основними характеристиками шаблонів «Декоратор», «Компонувальник» та «Міст», запам’ятовування поширених ситуацій, коли використання цих шаблонів є доцільним, набуття вмінь та навичок реалізації шаблонів під час створення програмного коду.
## Теоретичні відомості:
#### __Декоратор__
Це структурний шаблон проектування, який призначений для динамічного підключення додаткових станів та поведінки до об’єкта та є гнучкою альтернативою практиці створення підкласів з метою розширення функціональності. Об’єкт при цьому “не знає”, що він є “декорованим”, тому шаблон доцільно використовувати для розширення програмних систем. Відомий також під назвою Обгортка (Wrapper).

Структурний шаблон «Декоратор» потрібно використовувати, коли:
* обов’язки та поведінка об’єктів повинні додаватися динамічно
* конкретні реалізації повинні бути відокремлені від обов'язків і поведінки
* розширення об’єктів шляхом створення підкласів недоцільне або неможливе
* конкретні функції не повинні перебувати на верхніх рівнях ієрархії об'єктів
* необхідно реалізувати можливості, які потрібні не всім об’єктам та не завжди і можуть бути видалені при необхідності
* наявність великої кількості малих об’єктів, які мають схожу реалізацію, є припустимою

Учасники шаблону:
* __Component__ – клас, який задає інтерфейс для об’єктів, на які можуть бути динамічно покладені додаткові обов’язки, а також для майбутніх декораторів
* __ConcreteComponent__ - визначає об’єкт, до якого додаються нові стани та поведінка
* __Decorator__ – містить посилання на об’єкт компонент та успадковує реалізацію його інтерфейсу за замовчанням
* __ConcreteDecorator__ (ConcreteDecoratorA, конкретні декоратори

#### __Компонувальник__
Це структурний шаблон проектування, який призначений для створення деревоподібної структури для подання ієрархії об’єктів, де кожний об’єкт можна розглядати незалежно або як набір вкладених об’єктів через один інтерфейс. Таким чином, з’являється можливість уніфіковано, однаково поводитися з кожним об’єктом
Структурний шаблон

«Компонувальник» потрібно використовувати, коли:
* необхідно забезпечити ігнорування клієнтом істотних відмінностей між окремим об’єктом та складеним об’єктом
* необхідно реалізувати уніфіковану обробку всіх об’єктів
* шаблон «Декоратор», який містить операції типу Додати (Add), Видалити (Remove) та Знайти (Find)
* шаблон «Пристосуванець» для розділення компонентів за умови, що характеристика «місцезнаходження» може бути проігнорована і всі операції будуть починатися з кореневої вершини композиції об’єктів
* шаблон «Відвідувач» для локалізації операцій, які на даний момент розподілені між класами Composite та Component

Учасники шаблону:
* __Component__ – компонент, який задає інтерфейс для об’єктів, котрі компонуються. Також він надає відповідну реалізацію операцій за замовчанням, спільну для всіх класів; об’являє єдиний інтерфейс для доступу до нащадків та керування ними; визначає інтерфейс для доступу до батьківського елемента компонента у рекурсивній структурі та при необхідності реалізує його
* __Leaf__ – компонент без реалізації контейнерних функцій. Визначає листові вершини та не має нащадків. Визначає поведінку примітивних об’єктів у композиції; входить до складу контейнерів

#### __Міст__
Це структурний шаблон проектування, що дозволяє розділяти абстракцію і реалізацію таким чином, щоб вони могли змінюватися незалежно. Шаблон bridge (від англ. – «міст») використовує інкапсуляцію, агрегування та успадкування для того, щоб розділити відповідальність між класами. Відомий також під назвою Handle/Body (описувач/тіло)

Структурний шаблон «Міст» потрібно використовувати, коли:
* потрібно уникнути постійної прив'язки абстракції до реалізації / абстракція та реалізація не повинні бути зв’язаними під час компіляції
* конкретну реалізацію необхідно вибирати під час виконання програми
* абстракція та реалізація повинні бути незалежно розширюваними новими підкласами. У такому випадку «Міст» дозволяє комбінувати різні абстракції та реалізації та змінювати їх незалежно
* зміни в реалізації абстракції не повинні позначатися на клієнтах, тобто клієнтський код не повинен перекомпілювати
* деталі реалізації повинні бути прихованими від клієнта
* кількість класів швидко зростає, що є ознакою того, що ієрархію потрібно розділити на 2 частини

Учасники шаблону:
* __Abstraction__ визначає інтерфейс абстракції і агрегує (зберігає посилання) на об'єкт типу Implementor
* __Refined Abstraction__ (опціонально) - це більш специфічний підклас основної абстракції, який розширює інтерфейс, визначений нею
* __Implementor__ визначає інтерфейс для класів реалізації. Він не зобов'язаний точно відповідати інтерфейсу класу Abstraction, більше того обидва інтерфейси можуть бути абсолютно різні. Зазвичай інтерфейс класу Implementor надає тільки примітивні операції, а клас Abstraction визначає операції більш високого рівня, що базуються на цих примітивах
* __ConcreteImplementor__ - один з конкретних (платформо-залежних) виконавців

##### Індивідуальне завдання (Варіант 7)
1. Всі тварини сімейства котячих мають спільні риси: зріст, вагу, середовище проживання, вік, породу. Ті тварини, які мешкають у зоопарку, цирку, дома у людей, мають також ім’я. Кожна порода, окрім загальних дій, притаманних всім котячим (їсти, спати тощо), має свої власні дії (великі хижаки – рись, пума – полюють на здобич, домашні коти – граються із сонячним зайчиком тощо). Створити базовий клас «Тварина сімейства котячі», а також похідні від нього класи, які наслідують загальні риси та дії від нього, а також реалізують додаткові дії, притаманні конкретній тварині. Продемонструвати реалізацію структури класів
2. За допомогою шаблона проектування реалізувати механізм доведення наказу директора до всіх співробітників компанії. Директор інформує про наказ всіх своїх заступників на нараді. Заступники директора, в свою чергу, передають інформацію всім начальникам відділів, які їх підпорядковуються. Якщо начальник якогось відділупідпорядковується одразу декільком заступникам директора, тоді він отримає звістку про наказ декілька разів. Начальники відділів передають інформацію про наказ всім своїм підлеглим
