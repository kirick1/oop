# Лабораторна робота №2
## Тема роботи:
Реалізація складних структурних шаблонів проектування
## Мета роботи:
Ознаойомлення з основними характеристиками шаблонів «Заступник», «Фасад», «Адаптер» та «Легковаговик», запам’ятовування поширених ситуацій, коли використання цих шаблонів є доцільним, набуття вмінь та навичок реалізації шаблонів під час створення програмного коду
## Теоретичні відомості:
#### __Заступник__
Це структурний шаблон проектування, який забезпечує створення заступника об’єкта для контролю доступу до останнього через перехоплення всіх викликів. 

Надає об’єкт-заступник (surrogate) або об’єкт-замінник (placeholder).

Обгортаючи доступ до реального компонента, «Заступник»зменшує
складність роботи з ним.

Структурний шаблон «Заступник» потрібно використовувати, коли:
* створення об’єкту є “дорогою” операцією – можна створювати об’єкт тільки при першому зверненні до нього
* потрібно контролювати доступ до об’єкту: для різних об’єктів можна встановлювати різні рівні доступу
* потрібно організувати віддалений функціонал – заступник надає локального представника замість цільового об’єкта, що знаходиться в іншому адресному просторі
* потрібно виконувати додаткові дії при доступі до об'єкта – «розумне посилання

Види шаблону «Заступник»:
* __віртуальний заступник__: управляє створенням одного об’єкта через інший тоді, коли цей об’єкт реально потрібний (доцільно у випадках, якщо процес створення досить повільний або може бути визнаним непотрібним). Має назву ще lazy loading, on-demand loading, just-in-time loading. Може кешувати частину інформації про реальний Суб’єкт, щоб відкласти його створення
* __заступник для аутентифікації__ (__заступник-захисник__): перевіряє правильність умов доступу до об’єкту
* __віддалений заступник__: забезпечує зв’язок з Суб’єктом, який знаходиться у іншому адресному просторі (домені застосунку, процесі чи комп’ютері); кодує/декодує повідомлення, які надсилаються мережею
* __розумний заступник__: додає щось до запиту перед його надсиланням до мережі або змінює запит
* __кешуючий заступник__: забезпечує тимчасове зберігання результатів розрахунків до надсилання їх клієнтам, які можуть розділити ці результати

Учасники шаблону:

* __Proxy__:
1. зберігає посилання, яке дозволяє йому звертатися до реального суб'єкту, використовуючи інтерфейс класу Subject 
2. надає інтерфейс, ідентичний інтерфейсу Subject, тому заступник завжди може бути підставлений замість реального суб'єкта
3. контролює доступ до реального суб'єкту і може відповідати за його створення і видалення
4. виконує інші обов'язки, які залежать від виду заступника (remote proxies, virtual proxies, protection proxies etc.)
* __Subject__ - визначає спільний для __RealSubject__ і __Proxy__ інтерфейс, так що клас __Proxy__ можна використовувати скрізь, де очікується __RealSubject__
* __RealSubject__ – визначає реальний об'єкт, який подається за допомогою заступника

#### __Фасад__
Це структурний шаблон проектування, який структурує об’єкти, надаючи до них всіх доступ через єдиний шлюз. Надає єдиний, уніфікований інтерфейс до всієї підсистеми замість набору окремих та багаточисельних інтерфейсів. Фактично, “Фасад” визначає інтерфейс більш високого рівня, який спрощує використання системи

Структурний шаблон «Фасад» потрібно використовувати, коли:
* є необхідність у наданні простого інтерфейсу доступу до складної системи
* між клієнтами та класами реалізації абстракції існує багато залежностей і треба зменшити їхню кількість
* є необхідність розкласти підсистему на окремі шари, створити різні рівні доступу до підсистеми, розшарувати її

Учасники шаблону:
* __Facade__ - фасад:
1. проінформований про те, яким складовим системи потрібно переадресовувати запит
2. делегує запити клієнтів відповідним об’єктам всередині підсистеми.
* __Класи підсистеми__:
1. реалізують функціональність підсистеми
2. виконують дії, які потребує «Фасад» і які, в свою чергу, «Фасад» отримав від одного з клієнтів
3. нічого не “знають” про існування самого «Фасаду» (не зберігають посилань на нього)
4. реалізація компонентів підсистеми закрита та не видна зовнішнім компонентам

#### __Адаптер__
Це структурний шаблон проектування, призначений для організації використання функцій об'єкта, недоступного для модифікації, через спеціально створений інтерфейс.

«Адаптер» забезпечує спільну роботу класів з несумісними інтерфейсами шляхом створення спільного об’єкта, через який вони можуть взаємодіяти.

«Адаптер» – шаблон, що уніфікує класи та об’єкти.

Структурний шаблон «Адаптер» потрібно використовувати, коли:
* існуючий клас підтримує необхідні дані і поведінку, але має інтерфейс, який не відповідає певним вимогам (наприклад, при використанні існуючої бібліотеки, до класів якої немає доступу)
* необхідно створити повторно використовуваний клас, який повинен взаємодіяти із зазделегідь невідомими або непов’язаними з ним класами, які мають несумісні інтерфейси
* необхідно об’єднати інтерфейси декількох класів, причому в наявності можуть бути тільки об’єкти-підкласи кожного з цих класів, а не примірники цих класів

Учасники шаблону:
* __Target__ цільовий інтерфейс. Визначає інтерфейс, який залежить від предметної області і яким користується __Client__
* __Client__ взаємодіє з об'єктами, що задовольняють інтерфейсу __Target__
* __Adaptee__ адаптований інтерфейс. Визначає існуючий інтерфейс класу (бібліотеки), який потребує адаптації
* __Adapter__ клас, що адаптує інтерфейс __Adaptee__ до інтерфейсу __Target__

#### __Легковаговик__
Це структурний шаблон проектування, який структурує об'єкти таким чином, що з них створюється лише обмежений набір екземплярів замість великої множини об’єктів. «Адаптер» забезпечує спільну роботу класів з несумісними інтерфейсами шляхом створення спільного об’єкта, через який вони можуть взаємодіяти.

Полегшує повторне використання багатьох малих об’єктів, роблячи використання великої кількості об’єктів більш ефективною

Структурний шаблон «Легковаговик» потрібно використовувати, коли:
* у додатку використовується велика кількість подібних об'єктів, при цьому накладні витрати на їх зберігання є високими (може не вистачити пам’яті для їх одночасного розміщення в режимі runtime)
* більшу частину станів об'єктів можна винести назовні (у зону відповідальності клієнтів, які створюють і використовують ці об'єкти)
* багато нероздільних (unshared) об'єктів можна замінити невеликою кількістю поділюваних (shared) об'єктів, оскільки їх стан винесено назовні
* ідентичність кожного об’єкту не має значення

Учасники шаблону:
* __Flyweight__ визначає інтерфейс, за допомогою якого пристосуванці можуть отримувати зовнішній стан або певним чином на нього впливати
* __ConcreteFlyweight__ реалізує інтерфейс __Flyweight__ та додає при необхідності внутрішній стан. Об’єкт класу __ConcreteFlyweight__ повинен бути розділюваним (shared). Будь-який збережуваний ним стан повинен бути внутрішнім, тобто таким, що не залежить від контексту
* __UnsharedConcreteFlyweight__ нерозділюваний (unshared) конкретний пристосуванець. Не всі підкласи __Flyweight__ обов’язково повинні бути shared. Інтерфейс __Flyweight__ допускає розділення, але не нав’язує його. Часто у об’єктів __UnsharedConcreteFlyweight__ на деякому рівні структури пристосуванця є нащадки у вигляді об’єктів класу __ConcreteFlyweigh__
* __FlyweightFactory__ створює об’єкти-пристосуванці та управляє ними. Забезпечує необхідне розділення пристосуванців. Коли клієнт звертається до пристосуванця, об’єкт __FlyweightFactory__ надає існуючий екземпляр або створює новий, якщо готового ще немає
* __Client__ зберігає посилання на одного або декількох пристосуванців. Обчислює або зберігає зовнішній стан пристосуванців

##### Індивідуальне завдання (Варіант 7)
1. Розробити модуль до програмного забезпечення, що використовується у приймальній комісії вузу, який буде автоматично створювати папку з бланками електронних документів абітурієнта (анкета, оцінки на іспитах тощо) тільки у разі, якщо останній набрав прохідний бал.
2. Кухонний комбайн має функції кавниці, сокодавильниці, м’ясорубки, вимішувальника тіста тощо. За допомогою шаблона проектування реалізувати функціональність кожного побутового пристрою окремо (у вигляді окремих класів), а потім організувати новий клас, який дозволить об’єднати функції цих пристроїв разом.